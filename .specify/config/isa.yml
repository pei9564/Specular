# .speckit/config/isa.yml
# Instruction Set Architecture for Test Generation
#
# Defines the mapping from Gherkin step patterns to pytest-bdd step definitions.
# All templates use the Context Flow pattern:
#   context["payload"]   ← When steps accumulate from data tables
#   context["response"]  ← ensure_called() fires once, caches httpx Response
#   context["background_*"] ← Given steps store background entity data
#
# Shared infrastructure lives in tests/integration/conftest.py:
#   table_to_dicts()  — converts datatable (list[list[str]]) to list[dict]
#   context fixture   — mutable state carrier for Given → When → Then
#   ensure_called()   — lazy API trigger (fires once per scenario)
#   app / client      — FastAPI app factory with mocked dependencies
#   Common Given steps — auth, background entities, preconditions

definitions:
  # --- 1. MOCK_SETUP (Given) ---
  # Background data from Gherkin tables → context["background_*"]
  # Common steps are ALREADY defined in tests/integration/conftest.py.
  # Feature-specific Given steps go in the test file.
  - pattern: "系統中存在以下 {entity_type}:"
    type: "MOCK_SETUP"
    context: "Given"
    notes: "Parse data table into context for mock configuration."
    python_template: |
      # Defined in tests/integration/conftest.py (reusable across features):
      @given("系統中存在以下 {entity_type}:")
      def given_background_entities(datatable: Any, context: dict[str, Any]) -> None:
          context["background_{entity_key}"] = table_to_dicts(datatable)

  - pattern: '使用者 "{user_id}" 已登入且擁有 "{permission}" 權限'
    type: "MOCK_SETUP"
    context: "Given"
    notes: "Auth middleware mock — defined in conftest.py."
    python_template: |
      # Defined in tests/integration/conftest.py (reusable):
      @given(parsers.parse('使用者 "{user_id}" 已登入且擁有 "{permission}" 權限'))
      def given_user_logged_in(user_id: str, permission: str) -> None:
          pass  # Handled by app fixture middleware

  # --- 2. API_CALL (When) ---
  # Parse Gherkin data tables into context["payload"].
  # The actual HTTP request is NOT fired here — deferred to API_TRIGGER.
  - pattern: "使用者創建 {resource}:"
    type: "API_CALL"
    context: "When"
    notes: "Parse field/value table into context['payload']. Feature-specific."
    python_template: |
      @when("使用者創建 {resource}:")
      def when_create_resource(datatable: Any, context: dict[str, Any]) -> None:
          for row in table_to_dicts(datatable):
              context["payload"][row["field"]] = row["value"]

  - pattern: "同時綁定 {relation}:"
    type: "API_CALL"
    context: "When"
    notes: "Parse ID list table, append to context['payload']. Feature-specific."
    python_template: |
      @when("同時綁定 {relation}:")
      def when_bind_relation(datatable: Any, context: dict[str, Any]) -> None:
          id_column = datatable[0][0]  # e.g. "mcp_id"
          context["payload"][f"{id_column}s"] = [
              row[id_column] for row in table_to_dicts(datatable)
          ]

  # --- 3. API_TRIGGER ---
  # Bridges API_CALL (When) → API_ASSERT (Then).
  # Fires the HTTP request ONCE after all When steps complete.
  # Defined as a helper function in tests/integration/conftest.py.
  #
  # IMPORTANT: This is NOT a step definition — it's called by Then steps.
  # Then steps must call ensure_called() before any assertion.
  - pattern: "(internal — called by Then steps)"
    type: "API_TRIGGER"
    context: "Then (internal)"
    notes: |
      ensure_called() is defined in tests/integration/conftest.py.
      It configures mocks from context["background_*"] + context["payload"],
      fires the HTTP request, and caches the response in context["response"].
      Idempotent: fires only once per scenario.
    python_template: |
      # Defined in tests/integration/conftest.py (reusable):
      def ensure_called(
          context: dict[str, Any],
          client: TestClient,
          mock_mcp_repo: AsyncMock,
      ) -> None:
          if context["response"] is not None:
              return
          # Configure mocks from context["background_*"] + requested IDs
          # Fire POST /api/{resource} with context["payload"]
          # Store response in context["response"]

  # --- 4. API_ASSERT (Then) ---
  # Assert status code and response body from context["response"].
  # Feature-specific — patterns vary per feature.
  - pattern: '{resource} "{name}" 應成功建立'
    type: "API_ASSERT"
    context: "Then"
    notes: "Assert 201 + name match. Feature-specific."
    python_template: |
      @then(parsers.parse('{resource} "{name}" 應成功建立'))
      def then_created(name: str, context: dict[str, Any], client: TestClient, mock_mcp_repo: AsyncMock) -> None:
          ensure_called(context, client, mock_mcp_repo)
          resp = context["response"]
          assert resp.status_code == 201
          assert resp.json()["name"] == name

  - pattern: "創建應失敗"
    type: "API_ASSERT"
    context: "Then"
    notes: "Assert 4xx status. Feature-specific."
    python_template: |
      @then("創建應失敗")
      def then_failed(context: dict[str, Any], client: TestClient, mock_mcp_repo: AsyncMock) -> None:
          ensure_called(context, client, mock_mcp_repo)
          assert context["response"].status_code >= 400

  - pattern: '錯誤訊息應提示 "{text}"'
    type: "API_ASSERT"
    context: "Then"
    notes: "Assert error message contains text. Feature-specific."
    python_template: |
      @then(parsers.parse('錯誤訊息應提示 "{text}" ...'))
      def then_error_message(text: str, context: dict[str, Any], client: TestClient, mock_mcp_repo: AsyncMock) -> None:
          ensure_called(context, client, mock_mcp_repo)
          body = context["response"].json()
          assert text in body.get("message", "")

  # --- 5. DB_ASSERT (Then) ---
  # Assert mock repository call patterns from context["response"].
  # Feature-specific — patterns vary per feature.
  - pattern: "資料庫 {table} 表應包含:"
    type: "DB_ASSERT"
    context: "Then"
    notes: "Assert response body matches field/value table. Feature-specific."
    python_template: |
      @then("資料庫 {table} 表應包含:")
      def then_table_contains(datatable: Any, context: dict[str, Any], client: TestClient, mock_mcp_repo: AsyncMock) -> None:
          ensure_called(context, client, mock_mcp_repo)
          body = context["response"].json()
          for row in table_to_dicts(datatable):
              assert str(body.get(row["field"])) == row["value"]

  - pattern: '資料庫 {table} 表不應包含 "{name}"'
    type: "DB_ASSERT"
    context: "Then"
    notes: "Assert mock repo create was NOT called (atomicity). Feature-specific."
    python_template: |
      @then(parsers.parse('資料庫 {table} 表不應包含 "{name}"'))
      def then_no_record(name: str, context: dict[str, Any], client: TestClient, mock_mcp_repo: AsyncMock, mock_repo: AsyncMock) -> None:
          ensure_called(context, client, mock_mcp_repo)
          mock_repo.create_agent.assert_not_awaited()
